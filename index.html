<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <title>AR Balloon Pop Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial,
          sans-serif;
        background: #000;
        overflow: hidden;
        touch-action: none;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #camera-feed {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #game-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        transform: scaleX(-1);
      }

      #ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1000;
      }

      #game-ui {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        backdrop-filter: blur(10px);
        min-width: 200px;
      }

      #controls {
        position: absolute;
        bottom: 80px; /* Increased from 30px to 80px to prevent sticking to screen edge */
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        pointer-events: auto;
        align-items: center;
        margin-bottom: 20px; /* Added additional margin for better spacing */
      }
      
      .status-indicators {
        background: rgba(0,0,0,0.5);
        padding: 5px 10px;
        border-radius: 15px;
        margin-left: 10px;
      }
      
      .status-pill {
        color: white;
        font-size: 12px;
      }
      
      #hand-status-indicator {
        font-weight: bold;
        transition: color 0.3s ease;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 25px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        min-width: 120px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
        color: white;
        box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .btn-success {
        background: linear-gradient(135deg, #a8e6cf 0%, #88d8a3 100%);
        color: #2d3436;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      #game-stats {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        backdrop-filter: blur(10px);
        text-align: center;
      }

      .score {
        font-size: 24px;
        font-weight: bold;
        color: #ffe66d;
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s ease-in-out infinite;
        margin-right: 8px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        z-index: 2000;
      }

      #start-screen h1 {
        font-size: 3em;
        margin-bottom: 20px;
        text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      #start-screen p {
        font-size: 1.2em;
        margin-bottom: 30px;
        opacity: 0.9;
        max-width: 80%;
      }

      .celebration {
        position: absolute;
        pointer-events: none;
        font-size: 24px;
        font-weight: bold;
        color: #ffe66d;
        animation: celebrate 1s ease-out forwards;
        z-index: 999;
      }

      @keyframes celebrate {
        0% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
        100% {
          opacity: 0;
          transform: scale(1.5) translateY(-50px);
        }
      }
    </style>
  </head>
  <body>
    <!-- Start Screen -->
    <div id="start-screen">
      <h1>üéà AR Balloon Pop</h1>
      <p>
        Use your finger to pop balloons in AR space!<br />Point your camera and
        show your hand to play.
      </p>
      <button
        id="startGameBtn"
        class="btn btn-primary"
        style="pointer-events: auto"
      >
        üöÄ Start Game
      </button>
    </div>

    <div id="container" style="display: none">
      <!-- Camera feed -->
      <video id="camera-feed" autoplay muted playsinline></video>

      <!-- Game canvas for balloons and hand skeleton -->
      <canvas id="game-canvas"></canvas>

      <!-- UI Overlay -->
      <div id="ui-overlay">
        <!-- Game Status -->
        <div id="game-ui">
          <div>
            üñêÔ∏è <strong>Hand Tracking:</strong>
            <span id="hand-status">Initializing...</span>
          </div>
          <div style="margin-top: 8px">
            üéØ <strong>Aim:</strong> Point finger at balloons
          </div>
          <div style="margin-top: 8px">
            üí• <strong>Pop:</strong> Make "pinch" gesture
          </div>
        </div>

        <!-- Game Stats -->
        <div id="game-stats">
          <div class="score" id="score">0</div>
          <div style="margin-top: 5px">Balloons Popped</div>
          <div style="margin-top: 10px; font-size: 12px">
            <div>Time: <span id="game-time">0:00</span></div>
            <div>Balloons: <span id="balloon-count">0</span></div>
          </div>
        </div>

        <!-- Controls -->
        <div id="controls">
          <button id="switchCamera" class="btn btn-secondary">
            üì∑ Switch Camera
          </button>
          <button id="cameraInfo" class="btn btn-info">
            ‚ÑπÔ∏è Camera Info
          </button>
          <button id="resetGame" class="btn btn-success">üîÑ New Game</button>
          <div class="status-indicators" style="margin-left: 15px; background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 20px;">
            <div style="color: white; font-size: 14px;">
              <span>Hand Tracking: </span>
              <span id="hand-status-indicator" style="font-weight: bold; color: #4ECDC4;">Inactive</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      class BalloonPopGame {
        constructor() {
          this.hands = null;
          this.camera = null;
          this.videoElement = null;
          this.canvasElement = null;
          this.canvasCtx = null;
          this.isTracking = false;
          
          // Set default camera mode based on device type
          this.currentFacingMode = this.isMobileDevice() ? "environment" : "user";
          console.log(`Device detected as: ${this.isMobileDevice() ? 'mobile' : 'desktop'}, setting default camera to: ${this.currentFacingMode}`);

          // Game state
          this.gameStarted = false;
          this.score = 0;
          this.gameTime = 0;
          this.gameStartTime = 0;
          this.balloons = [];
          this.handLandmarks = null;
          this.lastPinchState = false;

          // Game settings
          this.maxBalloons = 8;
          this.balloonSpawnRate = 0.02; // Probability per frame
          this.balloonSpeed = 1;

          // Hand gesture detection
          this.fingerTipIndex = 8; // Index finger tip
          this.thumbTipIndex = 4; // Thumb tip
          this.pinchThreshold = 0.05; // Distance threshold for pinch

          this.init();
        }

        init() {
          this.videoElement = document.getElementById("camera-feed");
          this.canvasElement = document.getElementById("game-canvas");
          this.canvasCtx = this.canvasElement.getContext("2d");

          // Initialize hand status indicator
          const handStatus = document.getElementById('hand-status-indicator');
          if (handStatus) {
            handStatus.textContent = 'Initializing';
            handStatus.style.color = '#FFA500'; // Orange for initializing
          }

          this.setupEventListeners();
          this.resizeCanvas();
        }

        setupEventListeners() {
          document
            .getElementById("startGameBtn")
            .addEventListener("click", () => {
              this.startGame();
            });

          document
            .getElementById("switchCamera")
            .addEventListener("click", () => {
              this.switchCamera();
            });
            
          document
            .getElementById("cameraInfo")
            .addEventListener("click", () => {
              this.showCameraInfo();
            });

          document.getElementById("resetGame").addEventListener("click", () => {
            this.resetGame();
          });

          window.addEventListener("resize", () => {
            this.resizeCanvas();
          });
        }

        resizeCanvas() {
          this.canvasElement.width = window.innerWidth;
          this.canvasElement.height = window.innerHeight;
        }
        
        isMobileDevice() {
          // Check if the device is mobile based on user agent or screen size
          const userAgent = navigator.userAgent.toLowerCase();
          const mobileKeywords = ['android', 'iphone', 'ipad', 'ipod', 'blackberry', 'windows phone', 'mobile'];
          
          // Check user agent for mobile keywords
          const isMobileByUA = mobileKeywords.some(keyword => userAgent.includes(keyword));
          
          // Check screen size (typically mobile devices have smaller screens)
          const isMobileBySize = window.innerWidth <= 800 || window.innerHeight <= 600;
          
          // Check if touch is supported (most mobile devices support touch)
          const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
          
          // Return true if any of the checks indicate a mobile device
          return isMobileByUA || (isMobileBySize && isTouchDevice);
        }

        async startGame() {
          const startScreen = document.getElementById("start-screen");
          const container = document.getElementById("container");
          const startBtn = document.getElementById("startGameBtn");
          const handStatusIndicator = document.getElementById('hand-status-indicator');

          startBtn.innerHTML = '<div class="loading"></div>Starting...';
          startBtn.disabled = true;
          
          // Update hand status indicator
          if (handStatusIndicator) {
            handStatusIndicator.textContent = 'Starting...';
            handStatusIndicator.style.color = '#FFA500'; // Orange for initializing
          }

          try {
            // Initialize MediaPipe
            await this.initializeMediaPipe();

            // Start camera
            await this.startCamera();

            // Setup camera processing
            this.setupCameraProcessing();

            // Hide start screen and show game
            startScreen.style.display = "none";
            container.style.display = "block";
            
            // Update camera switch button text based on current mode
            const switchBtn = document.getElementById("switchCamera");
            switchBtn.textContent = this.currentFacingMode.includes('user') ? 'üì∑ Switch to Back Camera' : 'üì∑ Switch to Front Camera';

            // Start game logic
            this.isTracking = true;
            this.gameStarted = true;
            this.gameStartTime = Date.now();
            this.gameLoop();

            document.getElementById("hand-status").textContent = "Active";
            
            // Update hand status indicator to active
            if (handStatusIndicator) {
              handStatusIndicator.textContent = 'Active';
              handStatusIndicator.style.color = '#4ECDC4'; // Teal for active
            }
          } catch (error) {
            console.error("Error starting game:", error);
            startBtn.innerHTML = "‚ùå Error - Try Again";
            startBtn.disabled = false;
            
            // Update hand status indicator on error
            if (handStatusIndicator) {
              handStatusIndicator.textContent = 'Error';
              handStatusIndicator.style.color = '#FF5252'; // Red for error
            }

            if (error.message.includes("Camera")) {
              alert(
                "Camera permission required! Please allow camera access and try again."
              );
            }
          }
        }

        async initializeMediaPipe() {
          if (typeof Hands === "undefined") {
            throw new Error("MediaPipe Hands not loaded");
          }

          this.hands = new Hands({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            },
          });

          // For back camera (environment), we need to set selfieMode to false
          // For front camera (user), we need to set selfieMode to true
          const isFrontCamera = this.currentFacingMode.includes('user');
          
          await this.hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // Lower model complexity for better performance (0 is fastest)
            minDetectionConfidence: 0.6, // Slightly lower detection threshold for better performance
            minTrackingConfidence: 0.5,
            // Set selfieMode based on camera mode - true for front camera, false for back camera
            selfieMode: isFrontCamera,
          });
          
          console.log(`MediaPipe selfieMode set to: ${isFrontCamera} for ${this.currentFacingMode} camera`);

          this.hands.onResults((results) => {
            this.onHandResults(results);
          });
        }

        async startCamera() {
          try {
            // Stop existing stream if any
            if (this.videoElement.srcObject) {
              const tracks = this.videoElement.srcObject.getTracks();
              tracks.forEach((track) => {
                track.stop();
                console.log(`Stopped track: ${track.kind}`);
              });
              this.videoElement.srcObject = null;
            }

            // Add a small delay to ensure resources are released
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Check if we have a preferred camera stored
            const preferredCameraId = localStorage.getItem('preferredCameraId');
            const preferredCameraLabel = localStorage.getItem('preferredCameraLabel');
            
            if (preferredCameraId) {
              console.log(`Found preferred camera: ${preferredCameraLabel || preferredCameraId}`);
            } else {
              console.log(`No preferred camera found, using facing mode: ${this.currentFacingMode}`);
            }
            
            // Try with exact constraints first for more reliable camera switching
            let exactConstraints;
            
            if (preferredCameraId) {
              // If we have a preferred camera ID, use that instead of facing mode
              exactConstraints = {
                video: {
                  deviceId: { exact: preferredCameraId },
                  width: { ideal: 640, max: 1280 },
                  height: { ideal: 480, max: 720 },
                },
                audio: false, // Explicitly disable audio to avoid permission issues
              };
              console.log('Using preferred camera ID for constraints');
            } else {
              // Otherwise use facing mode as before
              exactConstraints = {
                video: {
                  facingMode: { exact: this.currentFacingMode },
                  width: { ideal: 640, max: 1280 },
                  height: { ideal: 480, max: 720 },
                },
                audio: false, // Explicitly disable audio to avoid permission issues
              };
              console.log('Using facing mode for constraints');
            }

            let stream;
            try {
              // First try with exact constraints
              console.log('Trying with exact facingMode constraints');
              stream = await navigator.mediaDevices.getUserMedia(exactConstraints);
              console.log('Successfully got stream with exact constraints');
            } catch (exactError) {
              console.warn(`Failed with exact constraints: ${exactError.name} - ${exactError.message}`);
              
              try {
                // Then try with preferred constraints
                console.log('Trying with preferred constraints (non-exact)');
                
                let preferredConstraints;
                const preferredCameraId = localStorage.getItem('preferredCameraId');
                
                if (preferredCameraId) {
                  // If we have a preferred camera ID, use that instead of facing mode
                  preferredConstraints = {
                    video: {
                      deviceId: preferredCameraId, // Without 'exact'
                      width: { ideal: 640, max: 1280 },
                      height: { ideal: 480, max: 720 },
                    },
                    audio: false, // Explicitly disable audio to avoid permission issues
                  };
                  console.log('Using preferred camera ID for non-exact constraints');
                } else {
                  // Otherwise use facing mode as before
                  preferredConstraints = {
                    video: {
                      facingMode: this.currentFacingMode, // Without 'exact'
                      width: { ideal: 640, max: 1280 },
                      height: { ideal: 480, max: 720 },
                    },
                    audio: false, // Explicitly disable audio to avoid permission issues
                  };
                  console.log('Using facing mode for non-exact constraints');
                }
                
                stream = await navigator.mediaDevices.getUserMedia(preferredConstraints);
                console.log('Successfully got stream with preferred constraints');
              } catch (preferredError) {
                console.warn(`Failed with preferred constraints: ${preferredError.name} - ${preferredError.message}`);
                
                // Last resort: try with basic constraints
                console.log('Trying with basic video constraints');
                stream = await navigator.mediaDevices.getUserMedia({
                  video: true,
                  audio: false // Explicitly disable audio to avoid permission issues
                });
                console.log('Successfully got stream with basic constraints');
              }
            }
            
            // Set the stream to the video element
            this.videoElement.srcObject = stream;
            
            // Log the actual tracks we got
            const tracks = stream.getVideoTracks();
            if (tracks.length > 0) {
              const settings = tracks[0].getSettings();
              console.log('Actual camera settings:', settings);
              
              // Store the originally requested facing mode
              const requestedFacingMode = this.currentFacingMode;
              let detectedFacingMode = null;
              
              // Some browsers/devices report the actual facingMode
              if (settings.facingMode) {
                console.log(`Actual facing mode from settings: ${settings.facingMode}`);
                detectedFacingMode = settings.facingMode;
              } else {
                // If facingMode isn't reported, try to determine from track label
                const trackLabel = (tracks[0].label || '').toLowerCase();
                console.log(`Camera track label: ${trackLabel}`);
                
                // Try to detect camera type from label
                if (trackLabel.includes('front') || trackLabel.includes('user') || trackLabel.includes('selfie')) {
                  console.log('Detected front camera from track label');
                  detectedFacingMode = 'user';
                } else if (trackLabel.includes('back') || trackLabel.includes('environment') || trackLabel.includes('rear')) {
                  console.log('Detected back camera from track label');
                  detectedFacingMode = 'environment';
                }
              }
              
              // If we detected a facing mode, update our tracking
              if (detectedFacingMode) {
                this.currentFacingMode = detectedFacingMode;
                console.log(`Updated current facing mode to: ${this.currentFacingMode}`);
              } else {
                console.log(`Could not detect camera type, keeping requested mode: ${this.currentFacingMode}`);
              }
              
              // Log if we got a different camera than requested
              if (requestedFacingMode !== this.currentFacingMode) {
                console.log(`Note: Requested ${requestedFacingMode} camera, but got ${this.currentFacingMode} camera`);
                // Alert the user if we couldn't get the requested camera
                if (requestedFacingMode === 'environment' && this.currentFacingMode === 'user') {
                  // Create a temporary status element if needed
                  let statusElement = document.getElementById('camera-switch-status');
                  if (!statusElement) {
                    statusElement = document.createElement('div');
                    statusElement.id = 'camera-switch-status';
                    statusElement.style.position = 'fixed';
                    statusElement.style.top = '50%';
                    statusElement.style.left = '50%';
                    statusElement.style.transform = 'translate(-50%, -50%)';
                    statusElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    statusElement.style.color = 'white';
                    statusElement.style.padding = '10px 20px';
                    statusElement.style.borderRadius = '20px';
                    statusElement.style.zIndex = '1000';
                    document.body.appendChild(statusElement);
                  }
                  statusElement.style.display = 'block';
                  statusElement.textContent = 'Could not access back camera';
                  setTimeout(() => {
                    statusElement.style.display = 'none';
                  }, 3000);
                }
              }
            }

            return new Promise((resolve, reject) => {
              this.videoElement.onloadedmetadata = () => {
                this.videoElement.play()
                  .then(() => {
                    console.log(
                      `Camera started: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`
                    );
                    resolve();
                  })
                  .catch(playError => {
                    console.error(`Error playing video: ${playError.message}`);
                    reject(playError);
                  });
              };
              this.videoElement.onerror = (e) => {
                console.error(`Video element error: ${e}`);
                reject(new Error(`Video element error: ${e}`));
              };
              
              // Set a timeout in case the camera doesn't initialize
              const timeoutId = setTimeout(() => {
                reject(new Error("Camera initialization timeout"));
              }, 8000);
              
              // Clear the timeout if metadata loads successfully
              this.videoElement.addEventListener('loadedmetadata', () => {
                clearTimeout(timeoutId);
              }, { once: true });
            });
          } catch (error) {
            console.error(`Camera access error: ${error.name} - ${error.message}`);
            throw error; // Throw the original error to preserve error type
          }
        }

        setupCameraProcessing() {
          // Properly stop and clean up existing camera
          if (this.camera) {
            try {
              this.camera.stop();
              console.log('Previous camera processing stopped');
            } catch (e) {
              console.warn('Error stopping previous camera:', e);
            }
            this.camera = null;
          }

          // Create a new camera processor with error handling
          try {
            this.camera = new Camera(this.videoElement, {
              onFrame: async () => {
                if (
                  this.hands &&
                  this.isTracking &&
                  this.videoElement.readyState >= 2
                ) {
                  try {
                    await this.hands.send({ image: this.videoElement });
                  } catch (e) {
                    console.warn('Error processing hand tracking frame:', e);
                  }
                }
              },
              width: 480, // Lower resolution for better performance
              height: 360, // Lower resolution for better performance
            });

            // Start camera with error handling
            this.camera.start()
              .then(() => {
                console.log('Camera processing started successfully');
                document.getElementById('hand-status-indicator').textContent = 'Active';
              })
              .catch(error => {
                console.error('Failed to start camera processing:', error);
                document.getElementById('hand-status-indicator').textContent = 'Error - Try Again';
              });
          } catch (error) {
            console.error('Error setting up camera processing:', error);
            document.getElementById('hand-status-indicator').textContent = 'Setup Failed';
          }
        }

        onHandResults(results) {
          // Update hand status indicator less frequently to reduce DOM operations
          if (!this.lastStatusUpdate || performance.now() - this.lastStatusUpdate > 500) {
            const handStatus = document.getElementById('hand-status-indicator');
            if (handStatus && this.isTracking) {
              if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handStatus.textContent = 'Detected';
                handStatus.style.color = '#4CAF50'; // Green for active detection
              } else {
                handStatus.textContent = 'Active';
                handStatus.style.color = '#4ECDC4'; // Teal for active but not detecting
              }
            }
            this.lastStatusUpdate = performance.now();
          }
          
          if (
            results.multiHandLandmarks &&
            results.multiHandLandmarks.length > 0
          ) {
            this.handLandmarks = results.multiHandLandmarks[0];
            this.detectPinchGesture();
          } else {
            this.handLandmarks = null;
          }
        }

        detectPinchGesture() {
          if (!this.handLandmarks) return;

          const fingerTip = this.handLandmarks[this.fingerTipIndex];
          const thumbTip = this.handLandmarks[this.thumbTipIndex];

          // Calculate distance between finger tip and thumb tip
          const distance = Math.sqrt(
            Math.pow(fingerTip.x - thumbTip.x, 2) +
              Math.pow(fingerTip.y - thumbTip.y, 2) +
              Math.pow(fingerTip.z - thumbTip.z, 2)
          );

          const isPinching = distance < this.pinchThreshold;

          // Detect pinch gesture (on transition from not pinching to pinching)
          if (isPinching && !this.lastPinchState) {
            // Use the finger tip position for popping (this will be flipped in onPinchGesture)
            this.onPinchGesture(fingerTip);
          }

          this.lastPinchState = isPinching;
        }

        onPinchGesture(fingerPosition) {
          const fingerX = fingerPosition.x * this.canvasElement.width;
          const fingerY = fingerPosition.y * this.canvasElement.height;

          // Check if finger is pointing at any balloon
          for (let i = this.balloons.length - 1; i >= 0; i--) {
            const balloon = this.balloons[i];
            const distance = Math.sqrt(
              Math.pow(fingerX - balloon.x, 2) +
                Math.pow(fingerY - balloon.y, 2)
            );

            if (distance < balloon.radius) {
              // Pop the balloon!
              this.popBalloon(i, fingerX, fingerY);
              break; // Only pop one balloon per gesture
            }
          }
        }

        popBalloon(index, x, y) {
          this.balloons.splice(index, 1);
          this.score++;
          document.getElementById("score").textContent = this.score;

          // Create celebration effect
          this.createCelebration(x, y);

          // Play pop sound effect (if you want to add audio later)
          this.createPopEffect(x, y);
        }

        createCelebration(x, y) {
          const celebration = document.createElement("div");
          celebration.className = "celebration";
          celebration.textContent = "+1";
          celebration.style.left = x + "px";
          celebration.style.top = y + "px";
          document.body.appendChild(celebration);

          setTimeout(() => {
            document.body.removeChild(celebration);
          }, 1000);
        }

        createPopEffect(x, y) {
          // Create particle effect for balloon pop
          for (let i = 0; i < 8; i++) {
            const particle = {
              x: x,
              y: y,
              vx: (Math.random() - 0.5) * 10,
              vy: (Math.random() - 0.5) * 10,
              life: 30,
              color: `hsl(${Math.random() * 360}, 70%, 60%)`,
            };

            // Add particles to a temporary array for rendering
            if (!this.particles) this.particles = [];
            this.particles.push(particle);
          }
        }

        spawnBalloon() {
          if (this.balloons.length >= this.maxBalloons) return;

          const balloon = {
            x: Math.random() * this.canvasElement.width,
            y: this.canvasElement.height + 50, // Start below screen
            radius: 30 + Math.random() * 20,
            color: `hsl(${Math.random() * 360}, 70%, 60%)`,
            speed: this.balloonSpeed + Math.random() * 2,
            bobOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.02 + Math.random() * 0.02,
          };

          this.balloons.push(balloon);
        }

        updateBalloons() {
          // Update existing balloons
          for (let i = this.balloons.length - 1; i >= 0; i--) {
            const balloon = this.balloons[i];

            // Move balloon up with slight bobbing motion
            balloon.y -= balloon.speed;
            balloon.x += Math.sin(balloon.bobOffset) * 0.5;
            balloon.bobOffset += balloon.bobSpeed;

            // Remove balloons that have gone off screen
            if (balloon.y + balloon.radius < 0) {
              this.balloons.splice(i, 1);
            }
          }

          // Spawn new balloons
          if (Math.random() < this.balloonSpawnRate) {
            this.spawnBalloon();
          }

          // Update particles
          if (this.particles) {
            for (let i = this.particles.length - 1; i >= 0; i--) {
              const particle = this.particles[i];
              particle.x += particle.vx;
              particle.y += particle.vy;
              particle.life--;

              if (particle.life <= 0) {
                this.particles.splice(i, 1);
              }
            }
          }
        }

        render() {
          const ctx = this.canvasCtx;
          const width = this.canvasElement.width;
          const height = this.canvasElement.height;

          // Clear canvas
          ctx.clearRect(0, 0, width, height);

          // Draw balloons - optimize by caching gradients and reducing operations
          this.balloons.forEach((balloon) => {
            // Only create gradient if it doesn't exist or balloon moved significantly
            if (!balloon.cachedGradient || 
                Math.abs(balloon.lastX - balloon.x) > 5 || 
                Math.abs(balloon.lastY - balloon.y) > 5) {
              
              balloon.lastX = balloon.x;
              balloon.lastY = balloon.y;
              
              // Create and cache the gradient
              balloon.cachedGradient = ctx.createRadialGradient(
                balloon.x - balloon.radius * 0.3,
                balloon.y - balloon.radius * 0.3,
                0,
                balloon.x,
                balloon.y,
                balloon.radius
              );
              balloon.cachedGradient.addColorStop(0, "rgba(255, 255, 255, 0.3)");
              balloon.cachedGradient.addColorStop(1, balloon.color);
            }

            ctx.fillStyle = balloon.cachedGradient;
            ctx.beginPath();
            ctx.arc(balloon.x, balloon.y, balloon.radius, 0, 2 * Math.PI);
            ctx.fill();

            // Balloon highlight
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            ctx.beginPath();
            ctx.arc(
              balloon.x - balloon.radius * 0.3,
              balloon.y - balloon.radius * 0.3,
              balloon.radius * 0.2,
              0,
              2 * Math.PI
            );
            ctx.fill();

            // Balloon string
            ctx.strokeStyle = "#8B4513";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(balloon.x, balloon.y + balloon.radius);
            ctx.lineTo(balloon.x, balloon.y + balloon.radius + 40);
            ctx.stroke();
          });

          // Draw particles
          if (this.particles) {
            this.particles.forEach((particle) => {
              ctx.fillStyle = particle.color;
              ctx.globalAlpha = particle.life / 30;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 3, 0, 2 * Math.PI);
              ctx.fill();
              ctx.globalAlpha = 1;
            });
          }

          // Draw hand skeleton if tracking
          if (this.handLandmarks) {
            this.drawHandSkeleton();
          }
        }

        drawHandSkeleton() {
          const ctx = this.canvasCtx;
          const width = this.canvasElement.width;
          const height = this.canvasElement.height;

          // Draw finger tip (aiming point)
          const fingerTip = this.handLandmarks[this.fingerTipIndex];
          const fingerX = fingerTip.x * width;
          const fingerY = fingerTip.y * height;

          // Draw aiming crosshair
          ctx.strokeStyle = this.lastPinchState ? "#FF6B6B" : "#4ECDC4";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(fingerX, fingerY, 15, 0, 2 * Math.PI);
          ctx.stroke();

          // Draw crosshair lines
          ctx.beginPath();
          ctx.moveTo(fingerX - 10, fingerY);
          ctx.lineTo(fingerX + 10, fingerY);
          ctx.moveTo(fingerX, fingerY - 10);
          ctx.lineTo(fingerX, fingerY + 10);
          ctx.stroke();

          // Draw simple hand outline (optional)
          ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
          ctx.lineWidth = 2;
          const handConnections = [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 4], // Thumb
            [0, 5],
            [5, 6],
            [6, 7],
            [7, 8], // Index
            [0, 9],
            [9, 10],
            [10, 11],
            [11, 12], // Middle
            [0, 13],
            [13, 14],
            [14, 15],
            [15, 16], // Ring
            [0, 17],
            [17, 18],
            [18, 19],
            [19, 20], // Pinky
            [5, 9],
            [9, 13],
            [13, 17], // Palm
          ];

          handConnections.forEach((connection) => {
            const start = this.handLandmarks[connection[0]];
            const end = this.handLandmarks[connection[1]];

            // Flip X coordinates for natural interaction
            const startX = (1 - start.x) * width;
            const startY = start.y * height;
            const endX = (1 - end.x) * width;
            const endY = end.y * height;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          });
        }

        updateGameStats() {
          // Update game time
          if (this.gameStarted) {
            this.gameTime = Math.floor(
              (Date.now() - this.gameStartTime) / 1000
            );
            const minutes = Math.floor(this.gameTime / 60);
            const seconds = this.gameTime % 60;
            document.getElementById(
              "game-time"
            ).textContent = `${minutes}:${seconds.toString().padStart(2, "0")}`;
          }

          // Update balloon count
          document.getElementById("balloon-count").textContent =
            this.balloons.length;
        }

        gameLoop() {
          if (!this.gameStarted) return;
          
          // Use frame limiting for better performance
          const now = performance.now();
          if (!this.lastFrameTime) this.lastFrameTime = now;
          
          // Limit to approximately 30 fps for better performance
          const frameInterval = 33; // ~30 fps (1000ms / 30 = 33.33ms)
          const elapsed = now - this.lastFrameTime;
          
          if (elapsed > frameInterval) {
            this.lastFrameTime = now - (elapsed % frameInterval);
            
            this.updateBalloons();
            this.render();
            this.updateGameStats();
          }
          
          requestAnimationFrame(() => this.gameLoop());
        }

        async switchCamera() {
          if (!this.isTracking) return;

          const btn = document.getElementById("switchCamera");
          btn.disabled = true;
          btn.textContent = "üîÑ Switching...";
          
          // Clear any preferred camera when manually switching
          localStorage.removeItem('preferredCameraId');
          localStorage.removeItem('preferredCameraLabel');
          console.log('Cleared preferred camera settings for manual camera switch');
          
          // Create or get existing status element for better user feedback
          let statusElement = document.getElementById('camera-switch-status');
          if (!statusElement) {
            statusElement = document.createElement('div');
            statusElement.id = 'camera-switch-status';
            statusElement.style.position = 'fixed';
            statusElement.style.top = '50%';
            statusElement.style.left = '50%';
            statusElement.style.transform = 'translate(-50%, -50%)';
            statusElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
            statusElement.style.color = 'white';
            statusElement.style.padding = '10px 20px';
            statusElement.style.borderRadius = '20px';
            statusElement.style.zIndex = '1000';
            document.body.appendChild(statusElement);
          }
          statusElement.style.display = 'block';
          statusElement.textContent = 'Switching camera...';

          // Store previous mode in case we need to revert
          const originalFacingMode = this.currentFacingMode;
          console.log(`Current camera mode: ${originalFacingMode}`);
          
          // Define the target facing mode we want to switch to
          // IMPORTANT: Make sure we're explicitly setting the opposite mode
          // Force the opposite mode regardless of what originalFacingMode reports
          const targetFacingMode = originalFacingMode.includes('environment') ? 'user' : 'environment';
          console.log(`Attempting to switch from ${originalFacingMode} to ${targetFacingMode}`);
          
          // Check if device has multiple cameras before attempting to switch
          let hasMultipleCameras = false;
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            hasMultipleCameras = videoDevices.length > 1;
            console.log(`Detected ${videoDevices.length} video devices:`, videoDevices.map(d => d.label || 'unnamed camera'));
            
            // Display detected cameras in the UI
            statusElement.textContent = `Detected ${videoDevices.length} camera(s)`;
            
            // Create a camera list element if it doesn't exist
            let cameraListElement = document.getElementById('camera-list');
            if (!cameraListElement) {
              cameraListElement = document.createElement('div');
              cameraListElement.id = 'camera-list';
              cameraListElement.style.position = 'fixed';
              cameraListElement.style.top = 'calc(50% + 40px)';
              cameraListElement.style.left = '50%';
              cameraListElement.style.transform = 'translate(-50%, 0)';
              cameraListElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
              cameraListElement.style.color = 'white';
              cameraListElement.style.padding = '10px 20px';
              cameraListElement.style.borderRadius = '10px';
              cameraListElement.style.zIndex = '999';
              cameraListElement.style.maxWidth = '80%';
              cameraListElement.style.fontSize = '14px';
              document.body.appendChild(cameraListElement);
            }
            
            // Display camera information
            cameraListElement.innerHTML = '';
            if (videoDevices.length > 0) {
              const cameraListTitle = document.createElement('div');
              cameraListTitle.textContent = 'Available cameras:';
              cameraListTitle.style.fontWeight = 'bold';
              cameraListTitle.style.marginBottom = '5px';
              cameraListElement.appendChild(cameraListTitle);
              
              videoDevices.forEach((device, index) => {
                const deviceInfo = document.createElement('div');
                deviceInfo.textContent = `${index + 1}: ${device.label || 'Camera ' + (index + 1)}`;
                cameraListElement.appendChild(deviceInfo);
              });
            }
            cameraListElement.style.display = 'block';
            
            // Hide camera list after a few seconds
            setTimeout(() => {
              if (cameraListElement) cameraListElement.style.display = 'none';
            }, 5000);
            
            if (!hasMultipleCameras) {
              console.warn('Device only has one camera, switching may not work as expected');
              statusElement.textContent = 'Your device may only have one camera';
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
          } catch (enumError) {
            console.warn('Could not enumerate devices:', enumError);
          }
          
          try {
            // First, stop MediaPipe camera processing
            if (this.camera) {
              try {
                await this.camera.stop();
                this.camera = null;
                console.log('Stopped MediaPipe camera');
              } catch (e) {
                console.warn('Error stopping MediaPipe camera:', e);
              }
            }
            
            // Stop current camera and its tracks
            if (this.videoElement.srcObject) {
              const tracks = this.videoElement.srcObject.getTracks();
              tracks.forEach(track => {
                track.stop();
                console.log(`Stopped track: ${track.kind}`);
              });
              this.videoElement.srcObject = null;
            }
            
            // Add a longer delay to ensure resources are released
            statusElement.textContent = 'Releasing camera resources...';
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Force garbage collection by nullifying references
            this.videoElement.srcObject = null;
            this.camera = null;
            
            // Additional delay after nullifying references
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Switch camera mode
            this.currentFacingMode = targetFacingMode;
            console.log(`Switching to ${this.currentFacingMode} camera`);

            // Restart camera with new facing mode
            statusElement.textContent = 'Starting new camera...';
            try {
              // Try with exact constraints first
              try {
                console.log('Trying with exact facingMode constraints');
                
                // On mobile, we need to be more specific with constraints
                // For mobile devices, we need to be more explicit about what we want
                const exactConstraints = {
                  video: {
                    facingMode: { exact: this.currentFacingMode },
                    width: { ideal: 640, max: 1280 },
                    height: { ideal: 480, max: 720 }
                  },
                  audio: false // Explicitly disable audio to avoid permission issues
                };
                
                // Add a retry mechanism for mobile devices
                let retryCount = 0;
                const maxRetries = 2;
                
                // Implement retry logic for getUserMedia
                let stream;
                let lastError;
                
                while (retryCount <= maxRetries) {
                  try {
                    if (retryCount > 0) {
                      console.log(`Retry attempt ${retryCount} for exact constraints...`);
                      statusElement.textContent = `Retrying camera (${retryCount}/${maxRetries})...`;
                      // Add a small delay between retries
                      await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    stream = await navigator.mediaDevices.getUserMedia(exactConstraints);
                    console.log('Successfully got stream with exact constraints');
                    this.videoElement.srcObject = stream;
                    break; // Success, exit the retry loop
                  } catch (err) {
                    lastError = err;
                    console.warn(`Attempt ${retryCount} failed:`, err);
                    retryCount++;
                    
                    if (retryCount > maxRetries) {
                      console.error('All retry attempts failed with exact constraints');
                      throw lastError; // Throw the last error to trigger the fallback
                    }
                  }
                }
                
                await new Promise((resolve) => {
                  this.videoElement.onloadedmetadata = () => {
                    this.videoElement.play()
                      .then(resolve)
                      .catch(e => {
                        console.error('Error playing video:', e);
                        resolve(); // Continue anyway
                      });
                  };
                  setTimeout(resolve, 3000); // Timeout fallback
                });
              } catch (exactError) {
                console.warn(`Failed with exact constraints: ${exactError.name} - ${exactError.message}`);
                
                // Try with preferred constraints (not exact)
                console.log('Trying with preferred facingMode constraints');
                const preferredConstraints = {
                  video: {
                    facingMode: this.currentFacingMode, // Without 'exact'
                    width: { ideal: 640, max: 1280 },
                    height: { ideal: 480, max: 720 }
                  },
                  audio: false // Explicitly disable audio to avoid permission issues
                };
                
                // Implement retry logic for preferred constraints
                let stream;
                let lastError;
                let retryCount = 0;
                const maxRetries = 2;
                
                while (retryCount <= maxRetries) {
                  try {
                    if (retryCount > 0) {
                      console.log(`Retry attempt ${retryCount} for preferred constraints...`);
                      statusElement.textContent = `Retrying camera (${retryCount}/${maxRetries})...`;
                      // Add a small delay between retries
                      await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    stream = await navigator.mediaDevices.getUserMedia(preferredConstraints);
                    console.log('Successfully got stream with preferred constraints');
                    this.videoElement.srcObject = stream;
                    break; // Success, exit the retry loop
                  } catch (err) {
                    lastError = err;
                    console.warn(`Preferred constraints attempt ${retryCount} failed:`, err);
                    retryCount++;
                    
                    if (retryCount > maxRetries) {
                      console.error('All retry attempts failed with preferred constraints');
                      throw lastError; // Throw the last error to trigger the basic fallback
                    }
                  }
                }
                
                await new Promise((resolve) => {
                  this.videoElement.onloadedmetadata = () => {
                    this.videoElement.play()
                      .then(resolve)
                      .catch(e => {
                        console.error('Error playing video:', e);
                        resolve(); // Continue anyway
                      });
                  };
                  setTimeout(resolve, 3000);
                });
              }
              
              // Log the actual tracks we got
              const tracks = this.videoElement.srcObject.getVideoTracks();
              if (tracks.length > 0) {
                const settings = tracks[0].getSettings();
                console.log('Camera settings after switch:', settings);
                // Some browsers/devices report the actual facingMode
                if (settings.facingMode) {
                  console.log(`Actual facing mode: ${settings.facingMode}`);
                  // Update our tracking of the current mode to match reality
                  this.currentFacingMode = settings.facingMode;
                } else {
                  // If facingMode isn't reported, try to determine from track label
                  const trackLabel = tracks[0].label.toLowerCase();
                  console.log(`Camera track label: ${trackLabel}`);
                  if (trackLabel.includes('front') || trackLabel.includes('user') || trackLabel.includes('selfie')) {
                    console.log('Detected front camera from track label');
                    this.currentFacingMode = 'user';
                  } else if (trackLabel.includes('back') || trackLabel.includes('environment') || trackLabel.includes('rear')) {
                    console.log('Detected back camera from track label');
                    this.currentFacingMode = 'environment';
                  }
                  // Otherwise keep the requested mode
                }
                
                // Update button text based on the ACTUAL camera mode - when in 'user' mode, offer to switch to back camera
                btn.textContent = this.currentFacingMode.includes('user') ? 'üì∑ Switch to Back Camera' : 'üì∑ Switch to Front Camera';
              }
              
              // Setup camera processing
              statusElement.textContent = 'Setting up processing...';
              
              // Update MediaPipe selfieMode based on current camera mode
              if (this.hands) {
                // For back camera (environment), we need to set selfieMode to false
                // For front camera (user), we need to set selfieMode to true
                const isFrontCamera = this.currentFacingMode.includes('user');
                await this.hands.setOptions({
                  maxNumHands: 1,
                  modelComplexity: 1,
                  minDetectionConfidence: 0.7,
                  minTrackingConfidence: 0.5,
                  // Set selfieMode based on camera mode - true for front camera, false for back camera
                  selfieMode: isFrontCamera,
                });
                console.log(`MediaPipe selfieMode updated to: ${isFrontCamera} for ${this.currentFacingMode} camera`);
              }
              
              await this.setupCameraProcessing();
              console.log('Camera processing setup complete');

              statusElement.textContent = 'Camera switched successfully!';
              setTimeout(() => {
                statusElement.style.display = 'none';
              }, 2000);
              return; // Success, exit the function
              
            } catch (cameraError) {
              // Handle specific camera errors
              console.error(`Camera error: ${cameraError.name} - ${cameraError.message}`);
              statusElement.textContent = 'Camera error. Trying basic mode...';
              
              // Try with very basic constraints as last resort
              try {
                // Store the target facing mode we were trying to switch to
                const targetFacingMode = this.currentFacingMode;
                console.log(`Attempting basic fallback after failing to get ${targetFacingMode} camera`);
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Reset currentFacingMode to ensure startCamera doesn't try to use the same constraints
                // that just failed
                this.currentFacingMode = 'user'; // Default to front camera for fallback
                
                // Use startCamera which has better fallback logic
                await this.startCamera();
                
                // At this point, startCamera should have updated currentFacingMode based on what we actually got
                
                // The currentFacingMode should now be updated by startCamera
                console.log(`Basic mode camera detected as: ${this.currentFacingMode}`);
                
                // Log if we couldn't get the camera we wanted
                if (targetFacingMode !== this.currentFacingMode) {
                  console.log(`Note: Tried to switch to ${targetFacingMode} camera, but got ${this.currentFacingMode} camera instead`);
                }
                
                // Update MediaPipe selfieMode based on the actual camera we got
                if (this.hands) {
                  const isFrontCamera = this.currentFacingMode.includes('user');
                  await this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5,
                    selfieMode: isFrontCamera,
                  });
                  console.log(`MediaPipe selfieMode set to ${isFrontCamera} in basic mode`);
                }
                
                this.setupCameraProcessing();
                
                // Update button text based on actual camera mode
                btn.textContent = this.currentFacingMode.includes('user') ? 
                  "üì∑ Switch to Back Camera" : "üì∑ Switch to Front Camera";
                statusElement.textContent = 'Camera active (basic mode)';

                setTimeout(() => {
                  statusElement.style.display = 'none';
                }, 2000);
                return;
              } catch (basicError) {
                console.error('Failed even with basic constraints:', basicError);
                throw basicError; // Give up and let the outer catch handle it
              }
            }
          } catch (error) {
            console.error(`Failed to switch camera: ${error.name} - ${error.message}`);
            statusElement.textContent = `Camera error: ${error.name}. Reverting...`;
            
            // Handle specific errors with user-friendly messages
            if (error.name === "NotReadableError") {
              alert("Camera is being used by another application. Please close other camera apps and try again.");
            } else if (error.name === "NotAllowedError") {
              alert("Camera access was denied. Please allow camera access and try again.");
            } else if (error.name === "NotFoundError") {
              alert("No camera found. Please check your device and try again.");
            } else if (error.name === "OverconstrainedError") {
              alert("Your device doesn't support switching between front and back cameras.");
            }
            
            // Revert camera mode on failure
            this.currentFacingMode = originalFacingMode;
            console.log(`Reverting to ${this.currentFacingMode} camera`);
            
            // Try to restart with previous mode
            try {
              await new Promise(resolve => setTimeout(resolve, 1000));
              await this.startCamera();
              this.setupCameraProcessing();
              statusElement.textContent = 'Reverted to previous camera';
              btn.textContent = this.currentFacingMode.includes('user') ? 'üì∑ Switch to Back Camera' : 'üì∑ Switch to Front Camera';
            } catch (restartError) {
              console.error(`Failed to restart camera: ${restartError.name} - ${restartError.message}`);
              statusElement.textContent = 'Camera switching failed. Please reload the page.';
              btn.textContent = "‚ùå Camera Error";
            }
          } finally {
            btn.disabled = false;
            
            // Remove status element after a delay if it's still in the DOM
            setTimeout(() => {
              statusElement.style.display = 'none';
            }, 3000);
          }
        }

        resetGame() {
          this.score = 0;
          this.gameTime = 0;
          this.gameStartTime = Date.now();
          this.balloons = [];
          this.particles = [];

          // Reset hand status indicator
          const handStatus = document.getElementById('hand-status-indicator');
          if (handStatus) {
            handStatus.textContent = 'Active';
            handStatus.style.color = '#4ECDC4'; // Teal for active
          }

          document.getElementById("score").textContent = "0";
          document.getElementById("game-time").textContent = "0:00";
          document.getElementById("balloon-count").textContent = "0";
        }
        
        async showCameraInfo() {
          try {
            // Create or get the camera-list element
            let cameraListElement = document.getElementById('camera-list');
            if (!cameraListElement) {
              cameraListElement = document.createElement('div');
              cameraListElement.id = 'camera-list';
              cameraListElement.style.position = 'absolute';
              cameraListElement.style.top = '50%';
              cameraListElement.style.left = '50%';
              cameraListElement.style.transform = 'translate(-50%, -50%)';
              cameraListElement.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
              cameraListElement.style.color = 'white';
              cameraListElement.style.padding = '20px';
              cameraListElement.style.borderRadius = '10px';
              cameraListElement.style.zIndex = '1000';
              cameraListElement.style.maxWidth = '80%';
              cameraListElement.style.maxHeight = '80%';
              cameraListElement.style.overflow = 'auto';
              cameraListElement.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5)';
              document.body.appendChild(cameraListElement);
            } else {
              // If it exists, clear previous content and show it
              cameraListElement.innerHTML = '';
              cameraListElement.style.display = 'block';
            }
            
            // Add title and close button
            const titleBar = document.createElement('div');
            titleBar.style.display = 'flex';
            titleBar.style.justifyContent = 'space-between';
            titleBar.style.alignItems = 'center';
            titleBar.style.marginBottom = '15px';
            
            const title = document.createElement('h3');
            title.textContent = 'Camera Information';
            title.style.margin = '0';
            
            const closeButton = document.createElement('button');
            closeButton.textContent = '‚úï';
            closeButton.style.background = 'none';
            closeButton.style.border = 'none';
            closeButton.style.color = 'white';
            closeButton.style.fontSize = '20px';
            closeButton.style.cursor = 'pointer';
            closeButton.onclick = () => {
              cameraListElement.style.display = 'none';
            };
            
            titleBar.appendChild(title);
            titleBar.appendChild(closeButton);
            cameraListElement.appendChild(titleBar);
            
            // Add loading indicator
            const loadingText = document.createElement('p');
            loadingText.textContent = 'Detecting video devices...';
            cameraListElement.appendChild(loadingText);
            
            // Get list of video devices
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            
            // Remove loading indicator
            cameraListElement.removeChild(loadingText);
            
            // Display current camera info
            const currentCameraInfo = document.createElement('div');
            currentCameraInfo.style.marginBottom = '15px';
            currentCameraInfo.style.padding = '10px';
            currentCameraInfo.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
            currentCameraInfo.style.borderRadius = '5px';
            
            const currentTitle = document.createElement('h4');
            currentTitle.textContent = 'Current Camera';
            currentTitle.style.marginTop = '0';
            currentCameraInfo.appendChild(currentTitle);
            
            const facingModeInfo = document.createElement('p');
            facingModeInfo.textContent = `Facing Mode: ${this.currentFacingMode}`;
            facingModeInfo.style.margin = '5px 0';
            currentCameraInfo.appendChild(facingModeInfo);
            
            if (this.videoElement) {
              const resolutionInfo = document.createElement('p');
              resolutionInfo.textContent = `Resolution: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`;
              resolutionInfo.style.margin = '5px 0';
              currentCameraInfo.appendChild(resolutionInfo);
            }
            
            cameraListElement.appendChild(currentCameraInfo);
            
            // Display available video devices with selection buttons
            const devicesTitle = document.createElement('h4');
            devicesTitle.textContent = 'Available Video Devices';
            cameraListElement.appendChild(devicesTitle);
            
            if (videoDevices.length === 0) {
              const noDevices = document.createElement('p');
              noDevices.textContent = 'No video devices detected';
              cameraListElement.appendChild(noDevices);
            } else {
              const devicesList = document.createElement('ul');
              devicesList.style.listStyleType = 'none';
              devicesList.style.padding = '0';
              
              videoDevices.forEach((device, index) => {
                const deviceItem = document.createElement('li');
                deviceItem.style.padding = '10px';
                deviceItem.style.margin = '5px 0';
                deviceItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                deviceItem.style.borderRadius = '5px';
                deviceItem.style.display = 'flex';
                deviceItem.style.justifyContent = 'space-between';
                deviceItem.style.alignItems = 'center';
                
                // Determine if this is likely a front or back camera based on label
                const deviceLabel = device.label || `Camera ${index + 1}`;
                const isFrontFacing = deviceLabel.toLowerCase().includes('front') || 
                                      deviceLabel.toLowerCase().includes('user') || 
                                      deviceLabel.toLowerCase().includes('selfie');
                const isBackFacing = deviceLabel.toLowerCase().includes('back') || 
                                     deviceLabel.toLowerCase().includes('environment') || 
                                     deviceLabel.toLowerCase().includes('rear');
                
                // Create device info div
                const deviceInfo = document.createElement('div');
                deviceInfo.style.flex = '1';
                
                // Add camera info with facing direction if detected
                let facingText = '';
                if (isFrontFacing) {
                  facingText = ', facing front';
                } else if (isBackFacing) {
                  facingText = ', facing back';
                }
                
                deviceInfo.textContent = `${index + 1}. ${deviceLabel} (ID: ${device.deviceId.substring(0, 8)}...${facingText})`;
                deviceItem.appendChild(deviceInfo);
                
                // Create test button
                const testButton = document.createElement('button');
                testButton.textContent = 'Test';
                testButton.style.backgroundColor = '#4CAF50';
                testButton.style.color = 'white';
                testButton.style.border = 'none';
                testButton.style.borderRadius = '4px';
                testButton.style.padding = '5px 10px';
                testButton.style.cursor = 'pointer';
                testButton.style.marginLeft = '10px';
                
                // Add click event to test this specific camera
                testButton.onclick = async () => {
                  try {
                    // Show status
                    const statusMsg = document.createElement('div');
                    statusMsg.textContent = `Testing camera ${index + 1}...`;
                    statusMsg.style.color = '#FFA500';
                    statusMsg.style.marginTop = '5px';
                    deviceItem.appendChild(statusMsg);
                    
                    // Stop current camera
                    if (this.videoElement.srcObject) {
                      const tracks = this.videoElement.srcObject.getTracks();
                      tracks.forEach(track => track.stop());
                      this.videoElement.srcObject = null;
                    }
                    
                    // Stop MediaPipe camera if running
                    if (this.camera) {
                      await this.camera.stop();
                      this.camera = null;
                    }
                    
                    // Try to access the selected camera by deviceId
                    const stream = await navigator.mediaDevices.getUserMedia({
                      video: {
                        deviceId: { exact: device.deviceId },
                        width: { ideal: 640, max: 1280 },
                        height: { ideal: 480, max: 720 }
                      },
                      audio: false
                    });
                    
                    // Set the stream to video element
                    this.videoElement.srcObject = stream;
                    
                    // Update status
                    statusMsg.textContent = `Camera ${index + 1} active`;
                    statusMsg.style.color = '#4ECDC4';
                    
                    // Update current facing mode based on detection
                    if (isFrontFacing) {
                      this.currentFacingMode = 'user';
                    } else if (isBackFacing) {
                      this.currentFacingMode = 'environment';
                    }
                    
                    // Setup camera processing again
                    await this.setupCameraProcessing();
                    
                    // Update camera info
                     facingModeInfo.textContent = `Facing Mode: ${this.currentFacingMode}`;
                     
                     // Find the resolution info element in the current camera info section
                     const resolutionInfoElements = cameraListElement.querySelectorAll('p');
                     let resolutionInfo = null;
                     for (const element of resolutionInfoElements) {
                       if (element.textContent.startsWith('Resolution:')) {
                         resolutionInfo = element;
                         break;
                       }
                     }
                     
                     // Update resolution if element found, otherwise create it
                     if (resolutionInfo && this.videoElement) {
                       resolutionInfo.textContent = `Resolution: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`;
                     } else if (this.videoElement) {
                       // If not found, create a new resolution info element
                       const newResolutionInfo = document.createElement('p');
                       newResolutionInfo.textContent = `Resolution: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`;
                       newResolutionInfo.style.margin = '5px 0';
                       // Add it after facing mode info
                       facingModeInfo.parentNode.insertBefore(newResolutionInfo, facingModeInfo.nextSibling);
                     }
                    
                    // Update button text
                    const switchBtn = document.getElementById("switchCamera");
                    if (switchBtn) {
                      switchBtn.textContent = this.currentFacingMode.includes('user') ? 'üì∑ Switch to Back Camera' : 'üì∑ Switch to Front Camera';
                      switchBtn.disabled = false;
                    }
                    
                    // Add a select button
                    const selectBtn = document.createElement('button');
                    selectBtn.textContent = 'Use This Camera';
                    selectBtn.style.backgroundColor = '#2196F3';
                    selectBtn.style.color = 'white';
                    selectBtn.style.border = 'none';
                    selectBtn.style.borderRadius = '4px';
                    selectBtn.style.padding = '5px 10px';
                    selectBtn.style.cursor = 'pointer';
                    selectBtn.style.marginLeft = '10px';
                    selectBtn.onclick = () => {
                      // Save this device ID for future use
                      localStorage.setItem('preferredCameraId', device.deviceId);
                      localStorage.setItem('preferredCameraLabel', deviceLabel);
                      
                      // Close the camera info panel
                      cameraListElement.style.display = 'none';
                      
                      // Show confirmation
                      const confirmationMsg = document.createElement('div');
                      confirmationMsg.textContent = `Camera ${index + 1} selected as default`;
                      confirmationMsg.style.position = 'fixed';
                      confirmationMsg.style.top = '50%';
                      confirmationMsg.style.left = '50%';
                      confirmationMsg.style.transform = 'translate(-50%, -50%)';
                      confirmationMsg.style.backgroundColor = 'rgba(0,0,0,0.7)';
                      confirmationMsg.style.color = 'white';
                      confirmationMsg.style.padding = '10px 20px';
                      confirmationMsg.style.borderRadius = '20px';
                      confirmationMsg.style.zIndex = '1000';
                      document.body.appendChild(confirmationMsg);
                      
                      setTimeout(() => {
                        document.body.removeChild(confirmationMsg);
                      }, 2000);
                    };
                    
                    // Add select button next to test button
                    deviceItem.appendChild(selectBtn);
                    
                  } catch (error) {
                    console.error(`Error testing camera ${index + 1}:`, error);
                    const statusMsg = deviceItem.querySelector('div:last-child');
                    if (statusMsg && statusMsg.style.color === '#FFA500') {
                      statusMsg.textContent = `Error: ${error.message}`;
                      statusMsg.style.color = '#FF5252';
                    } else {
                      const errorMsg = document.createElement('div');
                      errorMsg.textContent = `Error: ${error.message}`;
                      errorMsg.style.color = '#FF5252';
                      errorMsg.style.marginTop = '5px';
                      deviceItem.appendChild(errorMsg);
                    }
                  }
                };
                
                deviceItem.appendChild(testButton);
                devicesList.appendChild(deviceItem);
              });
              
              cameraListElement.appendChild(devicesList);
            }
            
            // Add device count summary
            const summary = document.createElement('p');
            summary.style.marginTop = '15px';
            summary.style.fontWeight = 'bold';
            summary.textContent = `Total video devices detected: ${videoDevices.length}`;
            cameraListElement.appendChild(summary);
            
            // Auto-hide after 15 seconds
            setTimeout(() => {
              if (cameraListElement && document.body.contains(cameraListElement)) {
                cameraListElement.style.display = 'none';
              }
            }, 15000);
            
          } catch (error) {
            console.error('Error showing camera info:', error);
            alert('Could not retrieve camera information: ' + error.message);
          }
        }
      }

      // Start the game when page loads
      document.addEventListener("DOMContentLoaded", () => {
        new BalloonPopGame();
      });
    </script>
  </body>
</html>
