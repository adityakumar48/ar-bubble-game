<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <title>AR Bubble Pop Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial,
          sans-serif;
        background: #000;
        overflow: hidden;
        touch-action: none;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #camera-feed {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #game-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: auto;
        transform: scaleX(-1);
      }

      #ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1000;
      }

      #game-ui {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        backdrop-filter: blur(10px);
        min-width: 200px;
      }

      #controls {
        position: absolute;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        pointer-events: auto;
        align-items: center;
        margin-bottom: 20px;
      }

      .status-indicators {
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 15px;
        margin-left: 10px;
      }

      .status-pill {
        color: white;
        font-size: 12px;
      }

      #hand-status-indicator {
        font-weight: bold;
        transition: color 0.3s ease;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 25px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        min-width: 120px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
        color: white;
        box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .btn-success {
        background: linear-gradient(135deg, #a8e6cf 0%, #88d8a3 100%);
        color: #2d3436;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      #game-stats {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        backdrop-filter: blur(10px);
        text-align: center;
      }

      .score {
        font-size: 24px;
        font-weight: bold;
        color: #ffe66d;
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s ease-in-out infinite;
        margin-right: 8px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        z-index: 2000;
      }

      #start-screen h1 {
        font-size: 3em;
        margin-bottom: 20px;
        text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      #start-screen p {
        font-size: 1.2em;
        margin-bottom: 30px;
        opacity: 0.9;
        max-width: 80%;
      }

      .celebration {
        position: absolute;
        pointer-events: none;
        font-size: 24px;
        font-weight: bold;
        color: #ffe66d;
        animation: celebrate 1s ease-out forwards;
        z-index: 999;
      }

      @keyframes celebrate {
        0% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
        100% {
          opacity: 0;
          transform: scale(1.5) translateY(-50px);
        }
      }
    </style>
  </head>
  <body>
    <!-- Start Screen -->
    <div id="start-screen">
      <h1>ü´ß AR Bubble Pop</h1>
      <p>
        Use your finger to pop bubbles in AR space!<br />Point your camera and
        show your hand to play.
      </p>
      <button
        id="startGameBtn"
        class="btn btn-primary"
        style="pointer-events: auto"
      >
        üöÄ Start Game
      </button>
    </div>

    <div id="container" style="display: none">
      <!-- Camera feed -->
      <video id="camera-feed" autoplay muted playsinline></video>

      <!-- Game canvas for bubbles and hand skeleton -->
      <canvas id="game-canvas"></canvas>

      <!-- UI Overlay -->
      <div id="ui-overlay">
        <!-- Game Status -->
        <div id="game-ui">
          <div>
            üñêÔ∏è <strong>Hand Tracking:</strong>
            <span id="hand-status">Initializing...</span>
          </div>
          <div style="margin-top: 8px">
            üéØ <strong>Aim:</strong> Align the crosshair on a bubble
          </div>
          <div style="margin-top: 8px">
            üí• <strong>Pop:</strong> Place the crosshair over the bubble to burst it
          </div>
        </div>

        <!-- Game Stats -->
        <div id="game-stats">
          <div class="score" id="score">0</div>
          <div style="margin-top: 5px">Bubbles Popped</div>
          <div style="margin-top: 10px; font-size: 12px">
            <div>Time: <span id="game-time">0:00</span></div>
            <div>Bubbles: <span id="balloon-count">0</span></div>
          </div>
        </div>

        <!-- Controls -->
        <div id="controls">
          <button id="switchCamera" class="btn btn-secondary">
            üì∑ Switch Camera
          </button>
          <button id="cameraInfo" class="btn btn-info">‚ÑπÔ∏è Camera Info</button>
          <button id="resetGame" class="btn btn-success">üîÑ New Game</button>
          <div
            class="status-indicators"
            style="
              margin-left: 15px;
              background: rgba(0, 0, 0, 0.5);
              padding: 8px 12px;
              border-radius: 20px;
            "
          >
            <div style="color: white; font-size: 14px">
              <span>Hand Tracking: </span>
              <span
                id="hand-status-indicator"
                style="font-weight: bold; color: #4ecdc4"
                >Inactive</span
              >
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      class BubblePopGame {
        constructor() {
          this.hands = null;
          this.camera = null;
          this.videoElement = null;
          this.canvasElement = null;
          this.canvasCtx = null;
          this.isTracking = false;

          // Improved camera detection
          this.currentFacingMode = this.detectInitialCamera();
          this.availableCameras = [];
          
          console.log(
            `Device detected as: ${
              this.isMobileDevice() ? "mobile" : "desktop"
            }, setting default camera to: ${this.currentFacingMode}`
          );

          // Game state
          this.gameStarted = false;
          this.score = 0;
          this.gameTime = 0;
          this.gameStartTime = 0;
          this.bubbles = [];
          this.handLandmarks = null;
          // Pinch detection removed; using tap-to-burst only

          // Game settings
          this.maxBubbles = 8;
          this.bubbleSpawnRate = 0.02;
          this.bubbleSpeed = 1;

          // Hand skeleton rendering
          this.fingerTipIndex = 8;
          this.thumbTipIndex = 4;

          this.init();
        }

        detectInitialCamera() {
          // Better detection logic
          const userAgent = navigator.userAgent.toLowerCase();
          const isMobile = /android|iphone|ipad|ipod|blackberry|windows phone|mobile/.test(userAgent);
          
          // On mobile, prefer back camera for AR experience
          // On desktop, prefer front camera for convenience
          return isMobile ? "environment" : "user";
        }

        async enumerateCameras() {
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            this.availableCameras = devices.filter(device => device.kind === 'videoinput');
            console.log(`Found ${this.availableCameras.length} cameras:`, 
              this.availableCameras.map(d => d.label || 'Unknown Camera'));
            return this.availableCameras;
          } catch (error) {
            console.warn('Could not enumerate cameras:', error);
            return [];
          }
        }

        init() {
          this.videoElement = document.getElementById("camera-feed");
          this.canvasElement = document.getElementById("game-canvas");
          this.canvasCtx = this.canvasElement.getContext("2d");

          const handStatus = document.getElementById("hand-status-indicator");
          if (handStatus) {
            handStatus.textContent = "Initializing";
            handStatus.style.color = "#FFA500";
          }

          this.setupEventListeners();
          this.resizeCanvas();
          
          // Add cleanup on page unload
          window.addEventListener('beforeunload', () => {
            this.cleanup();
          });
          
          // Handle visibility change: pause/resume instead of full cleanup (prevents black screen on mobile)
          document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
              this.pauseCamera();
            } else {
              this.resumeCamera();
            }
          });
        }
        
        cleanup() {
          console.log('Cleaning up resources...');
          this.stopProcessingLoop();
          
          // Stop stream monitoring
          if (this.streamMonitor) {
            clearInterval(this.streamMonitor);
            this.streamMonitor = null;
          }
          
          // Stop tracking
          this.isTracking = false;
          this.isRecovering = false;
          
          // Stop MediaPipe (hands)
          if (this.hands) {
            try {
              this.hands.close();
            } catch (e) {
              console.warn('Error closing MediaPipe:', e);
            }
            this.hands = null;
          }
          
          // Stop video stream
          if (this.videoElement && this.videoElement.srcObject) {
            const tracks = this.videoElement.srcObject.getTracks();
            tracks.forEach(track => {
              try {
                track.stop();
              } catch (e) {
                console.warn('Error stopping track:', e);
              }
            });
            this.videoElement.srcObject = null;
          }
        }
        
        pauseCamera() {
          // Pause only the video element; keep tracks alive to prevent back camera re-acquire issues
          if (this.videoElement) {
            try { this.videoElement.pause(); } catch {}
          }
          this.stopProcessingLoop();
        }
        
        async resumeCamera() {
          // Resume playback if stream exists; otherwise try to restart safely
          if (this.videoElement && this.videoElement.srcObject) {
            try {
              await this.videoElement.play();
            } catch (e) {
              console.warn('Video play failed on resume:', e);
            }
            this.startProcessingLoop();
            return;
          }
          try {
            await this.startCamera();
            this.setupCameraProcessing();
          } catch (e) {
            console.error('Failed to resume camera:', e);
          }
        }

        setupEventListeners() {
          document.getElementById("startGameBtn").addEventListener("click", () => {
            this.startGame();
          });

          document.getElementById("switchCamera").addEventListener("click", () => {
            this.switchCamera();
          });

          document.getElementById("cameraInfo").addEventListener("click", () => {
            this.showCameraInfo();
          });

          document.getElementById("resetGame").addEventListener("click", () => {
            this.resetGame();
          });

          window.addEventListener("resize", () => {
            this.resizeCanvas();
          });

          // Tap-to-pop on canvas
          const toCanvasCoords = (clientX, clientY) => {
            const rect = this.canvasElement.getBoundingClientRect();
            let x = ((clientX - rect.left) / rect.width) * this.canvasElement.width;
            let y = ((clientY - rect.top) / rect.height) * this.canvasElement.height;
            // Mirror X because canvas is visually flipped
            x = this.canvasElement.width - x;
            return { x, y };
          };

          const handleTap = (x, y) => {
            for (let i = this.bubbles.length - 1; i >= 0; i--) {
              const b = this.bubbles[i];
              const dx = x - b.x;
              const dy = y - b.y;
              if (dx * dx + dy * dy <= b.radius * b.radius) {
                this.popBubble(i, x, y);
                break;
              }
            }
          };

          this.canvasElement.addEventListener("pointerdown", (e) => {
            if (!this.gameStarted) return;
            // Ignore mouse clicks; allow touch/pen only
            if (e.pointerType === "mouse") return;
            const { x, y } = toCanvasCoords(e.clientX, e.clientY);
            handleTap(x, y);
          });

          // Prevent scrolling on touch devices while interacting on canvas
          this.canvasElement.addEventListener("touchstart", (e) => {
            e.preventDefault();
          }, { passive: false });
        }

        resizeCanvas() {
          this.canvasElement.width = window.innerWidth;
          this.canvasElement.height = window.innerHeight;
        }

        isMobileDevice() {
          const userAgent = navigator.userAgent.toLowerCase();
          const mobileKeywords = [
            "android", "iphone", "ipad", "ipod", "blackberry", "windows phone", "mobile"
          ];

          const isMobileByUA = mobileKeywords.some(keyword =>
            userAgent.includes(keyword)
          );

          const isMobileBySize = window.innerWidth <= 800 || window.innerHeight <= 600;
          const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;

          return isMobileByUA || (isMobileBySize && isTouchDevice);
        }

        async startGame() {
          const startScreen = document.getElementById("start-screen");
          const container = document.getElementById("container");
          const startBtn = document.getElementById("startGameBtn");
          const handStatusIndicator = document.getElementById("hand-status-indicator");

          startBtn.innerHTML = '<div class="loading"></div>Starting...';
          startBtn.disabled = true;

          if (handStatusIndicator) {
            handStatusIndicator.textContent = "Starting...";
            handStatusIndicator.style.color = "#FFA500";
          }

          try {
            // Enumerate cameras first
            await this.enumerateCameras();

            // Initialize MediaPipe
            await this.initializeMediaPipe();

            // Start camera
            await this.startCamera();

            // Setup camera processing
            this.setupCameraProcessing();

            startScreen.style.display = "none";
            container.style.display = "block";

            const switchBtn = document.getElementById("switchCamera");
            switchBtn.textContent = this.currentFacingMode.includes("user")
              ? "üì∑ Switch to Back Camera"
              : "üì∑ Switch to Front Camera";

            this.isTracking = true;
            this.gameStarted = true;
            this.gameStartTime = Date.now();
            this.gameLoop();

            document.getElementById("hand-status").textContent = "Active";

            if (handStatusIndicator) {
              handStatusIndicator.textContent = "Active";
              handStatusIndicator.style.color = "#4ECDC4";
            }
          } catch (error) {
            console.error("Error starting game:", error);
            startBtn.innerHTML = "‚ùå Error - Try Again";
            startBtn.disabled = false;

            if (handStatusIndicator) {
              handStatusIndicator.textContent = "Error";
              handStatusIndicator.style.color = "#FF5252";
            }

            this.showErrorMessage(error.message);
          }
        }

        showErrorMessage(message) {
          const modal = document.createElement("div");
          modal.style.position = "fixed";
          modal.style.top = "0";
          modal.style.left = "0";
          modal.style.width = "100%";
          modal.style.height = "100%";
          modal.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
          modal.style.display = "flex";
          modal.style.flexDirection = "column";
          modal.style.justifyContent = "center";
          modal.style.alignItems = "center";
          modal.style.zIndex = "3000";

          const messageContainer = document.createElement("div");
          messageContainer.style.backgroundColor = "white";
          messageContainer.style.padding = "20px";
          messageContainer.style.borderRadius = "10px";
          messageContainer.style.maxWidth = "80%";
          messageContainer.style.textAlign = "center";

          const errorIcon = document.createElement("div");
          errorIcon.innerHTML = "‚ùå";
          errorIcon.style.fontSize = "48px";
          errorIcon.style.marginBottom = "15px";
          messageContainer.appendChild(errorIcon);

          const messageText = document.createElement("div");
          messageText.textContent = message;
          messageText.style.marginBottom = "20px";
          messageContainer.appendChild(messageText);

          const okButton = document.createElement("button");
          okButton.textContent = "OK";
          okButton.style.padding = "10px 20px";
          okButton.style.backgroundColor = "#4ECDC4";
          okButton.style.color = "white";
          okButton.style.border = "none";
          okButton.style.borderRadius = "5px";
          okButton.style.cursor = "pointer";
          okButton.onclick = () => {
            document.body.removeChild(modal);
          };
          messageContainer.appendChild(okButton);

          modal.appendChild(messageContainer);
          document.body.appendChild(modal);
        }

        async initializeMediaPipe() {
          if (typeof Hands === "undefined") {
            throw new Error("MediaPipe Hands not loaded");
          }

          this.hands = new Hands({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            },
          });

          const isFrontCamera = this.currentFacingMode.includes("user");

          await this.hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.5,
            selfieMode: isFrontCamera,
          });

          console.log(
            `MediaPipe selfieMode set to: ${isFrontCamera} for ${this.currentFacingMode} camera`
          );

          this.hands.onResults((results) => {
            this.onHandResults(results);
          });
        }

        async startCamera() {
          try {
            // Request permission first
            try {
              await navigator.mediaDevices.getUserMedia({ video: true });
              console.log("Camera permission granted");
            } catch (permissionError) {
              throw new Error("Camera permission required! Please allow camera access and try again.");
            }

            // Stop existing stream
            if (this.videoElement.srcObject) {
              const tracks = this.videoElement.srcObject.getTracks();
              tracks.forEach(track => track.stop());
              this.videoElement.srcObject = null;
            }

            await new Promise(resolve => setTimeout(resolve, 500));

            // Detect mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Try different constraint strategies
            const strategies = [
              // Strategy 1: Preferred device ID if available
              () => {
                const preferredId = localStorage.getItem("preferredCameraId");
                if (preferredId) {
                  return {
                    video: {
                      deviceId: { exact: preferredId },
                      width: isMobile ? { ideal: 480, max: 640 } : { ideal: 640, max: 1280 },
                      height: isMobile ? { ideal: 360, max: 480 } : { ideal: 480, max: 720 },
                    },
                    audio: false,
                  };
                }
                return null;
              },
              
              // Strategy 2: Exact facing mode
              () => ({
                video: {
                  facingMode: { exact: this.currentFacingMode },
                  width: isMobile ? { ideal: 480, max: 640 } : { ideal: 640, max: 1280 },
                  height: isMobile ? { ideal: 360, max: 480 } : { ideal: 480, max: 720 },
                },
                audio: false,
              }),
              
              // Strategy 3: Ideal facing mode
              () => ({
                video: {
                  facingMode: { ideal: this.currentFacingMode },
                  width: isMobile ? { ideal: 480, max: 640 } : { ideal: 640, max: 1280 },
                  height: isMobile ? { ideal: 360, max: 480 } : { ideal: 480, max: 720 },
                },
                audio: false,
              }),
              
              // Strategy 4: Mobile-optimized basic video
              () => ({
                video: isMobile ? {
                  width: { ideal: 320, max: 480 },
                  height: { ideal: 240, max: 360 },
                  frameRate: { ideal: 15, max: 30 }
                } : {
                  width: { ideal: 640, max: 1280 },
                  height: { ideal: 480, max: 720 },
                },
                audio: false,
              }),
              
              // Strategy 5: Minimal constraints for mobile fallback
              () => isMobile ? {
                video: true,
                audio: false,
              } : null,
            ];

            let stream = null;
            let lastError = null;

            for (let i = 0; i < strategies.length; i++) {
              const constraints = strategies[i]();
              if (!constraints) continue;

              try {
                console.log(`Trying camera strategy ${i + 1}:`, constraints);
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log(`Strategy ${i + 1} successful`);
                break;
              } catch (error) {
                console.warn(`Strategy ${i + 1} failed:`, error.message);
                lastError = error;
                continue;
              }
            }

            if (!stream) {
              throw lastError || new Error("Could not access camera with any strategy");
            }

            this.videoElement.srcObject = stream;

            // Detect actual camera type
            const tracks = stream.getVideoTracks();
            if (tracks.length > 0) {
              const settings = tracks[0].getSettings();
              console.log("Camera settings:", settings);

              // Update facing mode based on what we actually got
              if (settings.facingMode) {
                this.currentFacingMode = settings.facingMode;
              } else {
                // Try to detect from label
                const label = tracks[0].label.toLowerCase();
                if (label.includes("front") || label.includes("user") || label.includes("selfie")) {
                  this.currentFacingMode = "user";
                } else if (label.includes("back") || label.includes("environment") || label.includes("rear")) {
                  this.currentFacingMode = "environment";
                }
              }

              console.log(`Using camera: ${this.currentFacingMode}`);
            }

            return new Promise((resolve, reject) => {
              let resolved = false;
              
              const handleSuccess = () => {
                if (resolved) return;
                resolved = true;
                console.log(`Camera started: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`);
                resolve();
              };
              
              const handleError = (error) => {
                if (resolved) return;
                resolved = true;
                reject(error);
              };
              
              this.videoElement.onloadedmetadata = () => {
                this.videoElement.play()
                  .then(handleSuccess)
                  .catch(handleError);
              };
              
              // For mobile devices, also try to resolve when video starts playing
              this.videoElement.onplaying = () => {
                if (!resolved && this.videoElement.videoWidth > 0) {
                  handleSuccess();
                }
              };
              
              // Increase timeout for mobile devices and add retry logic
              const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
              const timeoutDuration = isMobile ? 15000 : 8000;
              
              setTimeout(() => {
                if (!resolved) {
                  console.warn("Camera initialization timeout, attempting fallback...");
                  // Try to force play if video element has dimensions
                  if (this.videoElement.videoWidth > 0 && this.videoElement.videoHeight > 0) {
                    handleSuccess();
                  } else {
                    handleError(new Error("Camera initialization timeout - please try again or check camera permissions"));
                  }
                }
              }, timeoutDuration);
            });

          } catch (error) {
            console.error("Camera access error:", error);
            throw error;
          }
        }

        setupCameraProcessing() {
          // Use our own RAF loop instead of MediaPipe Camera to avoid conflicts on mobile
          try {
            // Stop any previous processing loop
            this.stopProcessingLoop();

            // Start monitoring the stream health
            this.monitorVideoStream();

            // Start the frame processing loop
            this.startProcessingLoop();

            console.log("Camera processing loop started");
            const indicator = document.getElementById("hand-status-indicator");
            if (indicator) indicator.textContent = "Active";
          } catch (error) {
            console.error("Error setting up camera processing:", error);
            const indicator = document.getElementById("hand-status-indicator");
            if (indicator) indicator.textContent = "Setup Failed";
          }
        }

        startProcessingLoop() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this._processing = false;

          const process = async () => {
            if (!this.isTracking || !this.hands || !this.videoElement) {
              this.rafId = requestAnimationFrame(process);
              return;
            }

            if (this.videoElement.readyState >= 2 && !this._processing) {
              // Check if video stream is still active
              if (this.videoElement.videoWidth === 0 || this.videoElement.videoHeight === 0) {
                console.warn("Video stream dimensions are zero, skipping frame");
                this.rafId = requestAnimationFrame(process);
                return;
              }

              this._processing = true;
              try {
                await this.hands.send({ image: this.videoElement });
              } catch (e) {
                console.warn("Error processing frame:", e);
              } finally {
                this._processing = false;
              }
            }

            this.rafId = requestAnimationFrame(process);
          };

          this.rafId = requestAnimationFrame(process);
        }

        stopProcessingLoop() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this._processing = false;
        }

        monitorVideoStream() {
          // Monitor video stream health
          if (this.streamMonitor) {
            clearInterval(this.streamMonitor);
          }
          
          this.streamMonitor = setInterval(() => {
            if (this.isTracking && this.videoElement) {
              const tracks = this.videoElement.srcObject?.getVideoTracks();
              if (!tracks || tracks.length === 0 || tracks[0].readyState === 'ended') {
                console.warn("Video track ended, attempting recovery...");
                this.handleStreamLoss();
              } else if (this.videoElement.videoWidth === 0 || this.videoElement.videoHeight === 0) {
                console.warn("Video dimensions lost, stream may be inactive");
              }
            }
          }, 2000);
        }

        async handleStreamLoss() {
          if (this.isRecovering) return;
          this.isRecovering = true;
          
          console.log("Attempting to recover camera stream...");
          document.getElementById("hand-status-indicator").textContent = "Recovering...";
          
          try {
            // Stop current resources
            if (this.camera) {
              await this.camera.stop();
              this.camera = null;
            }
            
            // Wait a moment
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Restart camera
            await this.startCamera();
            this.setupCameraProcessing();
            
            console.log("Camera stream recovered successfully");
            this.showNotification("Camera recovered");
          } catch (error) {
            console.error("Failed to recover camera stream:", error);
            document.getElementById("hand-status-indicator").textContent = "Recovery Failed";
            this.showNotification("Camera recovery failed - please refresh the page");
          } finally {
            this.isRecovering = false;
          }
        }

        async showCameraSelectionDialog() {
          // Create modal for camera selection
          const modal = document.createElement("div");
          modal.style.position = "fixed";
          modal.style.top = "0";
          modal.style.left = "0";
          modal.style.width = "100%";
          modal.style.height = "100%";
          modal.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
          modal.style.display = "flex";
          modal.style.flexDirection = "column";
          modal.style.justifyContent = "center";
          modal.style.alignItems = "center";
          modal.style.zIndex = "3000";

          // Create container for camera selection
          const container = document.createElement("div");
          container.style.backgroundColor = "white";
          container.style.padding = "20px";
          container.style.borderRadius = "10px";
          container.style.maxWidth = "80%";
          container.style.maxHeight = "80%";
          container.style.overflow = "auto";
          container.style.textAlign = "center";

          // Add title
          const title = document.createElement("h3");
          title.textContent = "Select Camera";
          title.style.marginBottom = "15px";
          container.appendChild(title);

          // Add loading text
          const loadingText = document.createElement("div");
          loadingText.textContent = "Loading cameras...";
          loadingText.style.margin = "20px 0";
          container.appendChild(loadingText);

          modal.appendChild(container);
          document.body.appendChild(modal);

          // Disable the switch camera button while dialog is open
          const switchBtn = document.getElementById("switchCamera");
          switchBtn.disabled = true;

          try {
            // Stop current camera resources
            if (this.camera) {
              try {
                await this.camera.stop();
                console.log("Stopped MediaPipe camera");
              } catch (e) {
                console.warn("Error stopping MediaPipe camera:", e);
              }
              this.camera = null;
            }

            if (this.videoElement.srcObject) {
              const tracks = this.videoElement.srcObject.getTracks();
              tracks.forEach(track => track.stop());
              this.videoElement.srcObject = null;
            }

            // Create button container with flex layout
            const buttonContainer = document.createElement("div");
            buttonContainer.style.display = "flex";
            buttonContainer.style.flexDirection = "column";
            buttonContainer.style.alignItems = "center";
            buttonContainer.style.marginTop = "20px";
            container.appendChild(buttonContainer);

            // Add close button
            const closeButton = document.createElement("button");
            closeButton.textContent = "Cancel";
            closeButton.style.padding = "10px 20px";
            closeButton.style.backgroundColor = "#f44336";
            closeButton.style.color = "white";
            closeButton.style.border = "none";
            closeButton.style.borderRadius = "5px";
            closeButton.style.cursor = "pointer";
            closeButton.style.marginTop = "20px";
            closeButton.onclick = () => {
              document.body.removeChild(modal);
              // Re-enable the switch camera button
              switchBtn.disabled = false;
              switchBtn.textContent = this.currentFacingMode.includes("user")
                ? "üì∑ Switch to Back Camera"
                : "üì∑ Switch to Front Camera";
            };

            // Enumerate video devices
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === "videoinput");

            // Remove loading text
            container.removeChild(loadingText);

            if (videoDevices.length === 0) {
              const noDevicesText = document.createElement("div");
              noDevicesText.textContent = "No cameras found";
              noDevicesText.style.margin = "20px 0";
              container.appendChild(noDevicesText);
            } else {
              // Add instruction text
              const instructionText = document.createElement("div");
              instructionText.textContent = "Select a camera:";
              instructionText.style.margin = "10px 0";
              container.appendChild(instructionText);

              // Create a button for each camera
              videoDevices.forEach((device, index) => {
                const button = document.createElement("button");
                
                // Determine if camera is front or back based on label
                const label = device.label || `Camera ${index + 1}`;
                let cameraType = "";
                
                if (label.toLowerCase().includes("front") || 
                    label.toLowerCase().includes("user") || 
                    label.toLowerCase().includes("selfie")) {
                  cameraType = " (Front)";
                } else if (label.toLowerCase().includes("back") || 
                         label.toLowerCase().includes("rear") || 
                         label.toLowerCase().includes("environment")) {
                  cameraType = " (Back)";
                }
                
                button.textContent = `${label}${cameraType}`;
                button.style.padding = "10px 15px";
                button.style.margin = "5px 0";
                button.style.backgroundColor = "#4ECDC4";
                button.style.color = "white";
                button.style.border = "none";
                button.style.borderRadius = "5px";
                button.style.cursor = "pointer";
                button.style.width = "100%";
                button.style.textAlign = "left";
                button.style.overflow = "hidden";
                button.style.textOverflow = "ellipsis";
                button.style.whiteSpace = "nowrap";
                
                button.onclick = async () => {
                  // Store selected camera in local storage
                  localStorage.setItem("preferredCameraId", device.deviceId);
                  localStorage.setItem("preferredCameraLabel", label);
                  
                  // Determine facing mode from label
                  if (label.toLowerCase().includes("front") || 
                      label.toLowerCase().includes("user") || 
                      label.toLowerCase().includes("selfie")) {
                    this.currentFacingMode = "user";
                  } else if (label.toLowerCase().includes("back") || 
                           label.toLowerCase().includes("rear") || 
                           label.toLowerCase().includes("environment")) {
                    this.currentFacingMode = "environment";
                  } else {
                    // If we can't determine from label, use the opposite of current
                    this.currentFacingMode = this.currentFacingMode.includes("user") 
                      ? "environment" 
                      : "user";
                  }
                  
                  console.log(`Selected camera: ${label}, facing mode: ${this.currentFacingMode}`);
                  
                  // Remove modal
                  document.body.removeChild(modal);
                  
                  // Stop current camera tracks
                  if (this.videoElement.srcObject) {
                    const tracks = this.videoElement.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    this.videoElement.srcObject = null;
                  }
                  
                  // Stop MediaPipe camera if running
                  if (this.camera) {
                    try {
                      await this.camera.stop();
                      console.log("Stopped MediaPipe camera");
                    } catch (e) {
                      console.warn("Error stopping MediaPipe camera:", e);
                    }
                    this.camera = null;
                  }
                  
                  // Create status element
                  const statusElement = document.createElement("div");
                  statusElement.textContent = `Switching to ${label}...`;
                  statusElement.style.position = "fixed";
                  statusElement.style.top = "50%";
                  statusElement.style.left = "50%";
                  statusElement.style.transform = "translate(-50%, -50%)";
                  statusElement.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
                  statusElement.style.color = "white";
                  statusElement.style.padding = "15px 25px";
                  statusElement.style.borderRadius = "10px";
                  statusElement.style.zIndex = "3000";
                  document.body.appendChild(statusElement);
                  
                  // Wait a bit for resources to be released
                  await new Promise(resolve => setTimeout(resolve, 1000));
                  
                  // Set up camera constraints with selected device
                  const constraints = {
                    video: {
                      deviceId: { exact: device.deviceId },
                      width: { ideal: 640, max: 1280 },
                      height: { ideal: 480, max: 720 }
                    },
                    audio: false
                  };
                  
                  try {
                    // Get user media with constraints
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.videoElement.srcObject = stream;
                    
                    // Wait for video to be ready
                    await new Promise((resolve, reject) => {
                      this.videoElement.onloadedmetadata = () => {
                        this.videoElement.play()
                          .then(resolve)
                          .catch(reject);
                      };
                      setTimeout(() => resolve(), 3000); // Fallback timeout
                    });
                    
                    // Update MediaPipe selfieMode based on camera mode
                    if (this.hands) {
                      // For front camera (user), we need to set selfieMode to true
                      const isFrontCamera = this.currentFacingMode.includes("user");
                      await this.hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.7,
                        minTrackingConfidence: 0.5,
                        // Set selfieMode based on camera mode - true for front camera, false for back camera
                        selfieMode: isFrontCamera,
                      });
                      console.log(`MediaPipe selfieMode updated to: ${isFrontCamera} for ${this.currentFacingMode} camera`);
                    }
                    
                    // Start camera processing
                    await this.setupCameraProcessing();
                    
                    // Update switch camera button
                    switchBtn.disabled = false;
                    switchBtn.textContent = this.currentFacingMode.includes("user")
                      ? "üì∑ Switch to Back Camera"
                      : "üì∑ Switch to Front Camera";
                    
                    // Remove status element
                    document.body.removeChild(statusElement);
                    
                  } catch (error) {
                    console.error("Failed to start camera:", error);
                    statusElement.textContent = `Error: ${error.message}`;
                    
                    // Remove status after a delay
                    setTimeout(() => {
                      if (document.body.contains(statusElement)) {
                        document.body.removeChild(statusElement);
                      }
                    }, 3000);
                    
                    // Re-enable switch camera button
                    switchBtn.disabled = false;
                    switchBtn.textContent = this.currentFacingMode.includes("user")
                      ? "üì∑ Switch to Back Camera"
                      : "üì∑ Switch to Front Camera";
                  }
                };
                
                buttonContainer.appendChild(button);
              });
            }
            
            container.appendChild(closeButton);
            
          } catch (error) {
            console.error("Error in camera selection dialog:", error);
            // Re-enable switch camera button
            switchBtn.disabled = false;
            switchBtn.textContent = this.currentFacingMode.includes("user")
              ? "üì∑ Switch to Back Camera"
              : "üì∑ Switch to Front Camera";
            
            // Remove modal
            if (document.body.contains(modal)) {
              document.body.removeChild(modal);
            }
            
            this.showNotification(`Error: ${error.message}`);
          }
        }
        
        async switchCamera() {
          if (!this.isTracking) return;

          const btn = document.getElementById("switchCamera");
          btn.disabled = true;
          btn.textContent = "üîÑ Switching...";

          // Clear preferred camera
          localStorage.removeItem("preferredCameraId");
          localStorage.removeItem("preferredCameraLabel");

          // Show camera selection dialog
          await this.showCameraSelectionDialog();
          return;
        }

        getCurrentCameraDeviceId() {
          if (this.videoElement.srcObject) {
            const tracks = this.videoElement.srcObject.getVideoTracks();
            if (tracks.length > 0) {
              const settings = tracks[0].getSettings();
              return settings.deviceId;
            }
          }
          return localStorage.getItem("preferredCameraId");
        }

        findNextCamera(currentDeviceId) {
          if (this.availableCameras.length <= 1) return null;
          
          const currentIndex = this.availableCameras.findIndex(camera => camera.deviceId === currentDeviceId);
          
          if (currentIndex === -1) {
            // Current camera not found, return first available
            return this.availableCameras[0];
          }
          
          // Return next camera, or first if at end
          const nextIndex = (currentIndex + 1) % this.availableCameras.length;
          return this.availableCameras[nextIndex];
        }

        async startCameraWithDevice(deviceId) {
          try {
            // Stop existing stream
            if (this.videoElement.srcObject) {
              const tracks = this.videoElement.srcObject.getTracks();
              tracks.forEach(track => track.stop());
              this.videoElement.srcObject = null;
            }

            await new Promise(resolve => setTimeout(resolve, 300));

            const constraints = {
              video: {
                deviceId: { exact: deviceId },
                width: { ideal: 640, max: 1280 },
                height: { ideal: 480, max: 720 },
              },
              audio: false,
            };

            console.log("Starting camera with device:", deviceId);
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            
            this.videoElement.srcObject = stream;

            // Update camera info
            const tracks = stream.getVideoTracks();
            if (tracks.length > 0) {
              const settings = tracks[0].getSettings();
              console.log("Camera settings:", settings);
              
              if (settings.facingMode) {
                this.currentFacingMode = settings.facingMode;
              }
            }

            return new Promise((resolve, reject) => {
              this.videoElement.onloadedmetadata = () => {
                this.videoElement.play()
                  .then(() => {
                    console.log(`Camera started: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`);
                    resolve();
                  })
                  .catch(reject);
              };
              
              setTimeout(() => reject(new Error("Camera initialization timeout")), 8000);
            });

          } catch (error) {
            console.error("Camera device access error:", error);
            throw error;
          }
        }

        showNotification(message) {
          const notification = document.createElement('div');
          notification.textContent = message;
          notification.style.position = 'fixed';
          notification.style.top = '50%';
          notification.style.left = '50%';
          notification.style.transform = 'translate(-50%, -50%)';
          notification.style.backgroundColor = 'rgba(0,0,0,0.7)';
          notification.style.color = 'white';
          notification.style.padding = '10px 20px';
          notification.style.borderRadius = '20px';
          notification.style.zIndex = '1000';
          document.body.appendChild(notification);

          setTimeout(() => {
            if (document.body.contains(notification)) {
              document.body.removeChild(notification);
            }
          }, 3000);
        }

        resetGame() {
          this.score = 0;
          this.gameTime = 0;
          this.gameStartTime = Date.now();
          this.bubbles = [];
          this.particles = [];

          const handStatus = document.getElementById("hand-status-indicator");
          if (handStatus) {
            handStatus.textContent = "Active";
            handStatus.style.color = "#4ECDC4";
          }

          document.getElementById("score").textContent = "0";
          document.getElementById("game-time").textContent = "0:00";
          document.getElementById("balloon-count").textContent = "0";
        }

        async showCameraInfo() {
          try {
            await this.enumerateCameras();
            
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '2000';

            const content = document.createElement('div');
            content.style.backgroundColor = 'white';
            content.style.padding = '20px';
            content.style.borderRadius = '10px';
            content.style.maxWidth = '80%';
            content.style.maxHeight = '80%';
            content.style.overflow = 'auto';

            content.innerHTML = `
              <h3>Camera Information</h3>
              <p><strong>Current Camera:</strong> ${this.currentFacingMode}</p>
              <p><strong>Resolution:</strong> ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}</p>
              <h4>Available Cameras (${this.availableCameras.length}):</h4>
              <ul>
                ${this.availableCameras.map((camera, index) => 
                  `<li>${index + 1}. ${camera.label || 'Unknown Camera'}</li>`
                ).join('')}
              </ul>
              <button onclick="this.parentElement.parentElement.remove()" 
                style="padding: 10px 20px; background: #4ECDC4; color: white; border: none; border-radius: 5px; cursor: pointer;">
                Close
              </button>
            `;

            modal.appendChild(content);
            document.body.appendChild(modal);

          } catch (error) {
            this.showNotification('Could not retrieve camera info');
          }
        }

        onHandResults(results) {
          if (!this.lastStatusUpdate || performance.now() - this.lastStatusUpdate > 500) {
            const handStatus = document.getElementById("hand-status-indicator");
            if (handStatus && this.isTracking) {
              if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                if (results.multiHandedness && results.multiHandedness.length > 0) {
                  const handType = results.multiHandedness[0].label;
                  handStatus.textContent = `Detected (${handType})`;
                } else {
                  handStatus.textContent = "Detected";
                }
                handStatus.style.color = "#4CAF50";
              } else {
                handStatus.textContent = "Active";
                handStatus.style.color = "#4ECDC4";
              }
            }
            this.lastStatusUpdate = performance.now();
          }

          if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            this.handLandmarks = results.multiHandLandmarks[0];
            if (results.multiHandedness && results.multiHandedness.length > 0) {
              this.handType = results.multiHandedness[0].label;
            }
            // Pinch no longer required for popping; keep landmarks for optional visuals
            // this.detectPinchGesture();
          } else {
            this.handLandmarks = null;
            this.handType = null;
          }
        }

        // Pinch detection removed; using tap-to-burst only


        // onPinchGesture removed; using tap-to-burst only


        popBubble(index, x, y) {
          this.bubbles.splice(index, 1);
          this.score++;
          document.getElementById("score").textContent = this.score;

          this.createCelebration(x, y);
          this.createPopEffect(x, y);
          this.takeScreenshotAndDownload();
        }
        
        takeScreenshotAndDownload() {
          const screenshotCanvas = document.createElement('canvas');
          screenshotCanvas.width = this.canvasElement.width;
          screenshotCanvas.height = this.canvasElement.height;
          const screenshotCtx = screenshotCanvas.getContext('2d');
          
          if (this.videoElement && this.videoElement.videoWidth > 0) {
            screenshotCtx.drawImage(this.videoElement, 0, 0, screenshotCanvas.width, screenshotCanvas.height);
          }
          
          screenshotCtx.drawImage(this.canvasElement, 0, 0);
          
          screenshotCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          screenshotCtx.fillRect(10, 10, 150, 40);
          screenshotCtx.font = 'bold 20px Arial';
          screenshotCtx.fillStyle = 'white';
          screenshotCtx.fillText(`Score: ${this.score}`, 20, 35);
          
          const imageDataURL = screenshotCanvas.toDataURL('image/png');
          
          const downloadLink = document.createElement('a');
          downloadLink.href = imageDataURL;
          downloadLink.download = `bubble-pop-score-${this.score}-${new Date().getTime()}.png`;
          
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          
          this.showScreenshotNotification();
        }
        
        showScreenshotNotification() {
          const notification = document.createElement('div');
          notification.textContent = 'üì∏ Screenshot saved!';
          notification.style.position = 'fixed';
          notification.style.bottom = '20px';
          notification.style.left = '50%';
          notification.style.transform = 'translateX(-50%)';
          notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
          notification.style.color = 'white';
          notification.style.padding = '10px 20px';
          notification.style.borderRadius = '20px';
          notification.style.zIndex = '1000';
          notification.style.fontWeight = 'bold';
          
          document.body.appendChild(notification);
          
          setTimeout(() => {
            document.body.removeChild(notification);
          }, 3000);
        }

        createCelebration(x, y) {
          const celebration = document.createElement("div");
          celebration.className = "celebration";
          celebration.textContent = "+1";
          celebration.style.left = x + "px";
          celebration.style.top = y + "px";
          document.body.appendChild(celebration);

          setTimeout(() => {
            document.body.removeChild(celebration);
          }, 1000);
        }

        createPopEffect(x, y) {
          for (let i = 0; i < 6; i++) {
            const particle = {
              x: x,
              y: y,
              vx: (Math.random() - 0.5) * 6,
              vy: (Math.random() - 0.5) * 6 - 2,
              life: 15,
              color: `hsla(${180 + Math.random() * 40}, 70%, 70%, 0.7)`,
              size: 2 + Math.random() * 3,
            };

            if (!this.particles) this.particles = [];
            this.particles.push(particle);
          }
        }

        spawnBubble() {
          if (this.bubbles.length >= this.maxBubbles) return;

          const bubble = {
            x: Math.random() * this.canvasElement.width,
            y: this.canvasElement.height + 50,
            radius: 15 + Math.random() * 25,
            color: `hsla(${180 + Math.random() * 40}, 70%, 70%, 0.7)`,
            speed: this.bubbleSpeed + Math.random() * 1.5,
            bobOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.03 + Math.random() * 0.03,
            lastX: 0,
            lastY: 0,
          };

          this.bubbles.push(bubble);
        }

        updateBubbles() {
          for (let i = this.bubbles.length - 1; i >= 0; i--) {
            const bubble = this.bubbles[i];

            bubble.y -= bubble.speed;
            bubble.x += Math.sin(bubble.bobOffset) * 1.2;
            bubble.bobOffset += bubble.bobSpeed;

            bubble.x += (Math.random() - 0.5) * 0.8;
            bubble.speed = Math.max(0.5, bubble.speed * 0.995);

            if (bubble.y + bubble.radius < 0) {
              this.bubbles.splice(i, 1);
            }
          }

          if (Math.random() < this.bubbleSpawnRate) {
            this.spawnBubble();
          }

          if (this.particles) {
            for (let i = this.particles.length - 1; i >= 0; i--) {
              const particle = this.particles[i];
              particle.x += particle.vx;
              particle.y += particle.vy;
              particle.life--;

              if (particle.life <= 0) {
                this.particles.splice(i, 1);
              }
            }
          }
        }

        render() {
          const ctx = this.canvasCtx;
          const width = this.canvasElement.width;
          const height = this.canvasElement.height;

          ctx.clearRect(0, 0, width, height);

          this.bubbles.forEach((bubble) => {
            if (
              !bubble.cachedGradient ||
              Math.abs(bubble.lastX - bubble.x) > 5 ||
              Math.abs(bubble.lastY - bubble.y) > 5
            ) {
              bubble.lastX = bubble.x;
              bubble.lastY = bubble.y;

              bubble.cachedGradient = ctx.createRadialGradient(
                bubble.x - bubble.radius * 0.3,
                bubble.y - bubble.radius * 0.3,
                0,
                bubble.x,
                bubble.y,
                bubble.radius
              );
              bubble.cachedGradient.addColorStop(0, "rgba(255, 255, 255, 0.5)");
              bubble.cachedGradient.addColorStop(0.7, bubble.color);
              bubble.cachedGradient.addColorStop(1, "rgba(255, 255, 255, 0.2)");
            }

            ctx.fillStyle = bubble.cachedGradient;
            ctx.beginPath();
            ctx.arc(bubble.x, bubble.y, bubble.radius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.beginPath();
            ctx.arc(
              bubble.x - bubble.radius * 0.3,
              bubble.y - bubble.radius * 0.3,
              bubble.radius * 0.15,
              0,
              2 * Math.PI
            );
            ctx.fill();

            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.beginPath();
            ctx.arc(
              bubble.x + bubble.radius * 0.1,
              bubble.y - bubble.radius * 0.1,
              bubble.radius * 0.05,
              0,
              2 * Math.PI
            );
            ctx.fill();
          });

          if (this.particles) {
            this.particles.forEach((particle) => {
              ctx.fillStyle = particle.color;
              ctx.globalAlpha = particle.life / 15;
              ctx.beginPath();
              ctx.arc(
                particle.x,
                particle.y,
                particle.size || 3,
                0,
                2 * Math.PI
              );
              ctx.fill();
              ctx.globalAlpha = 1;
            });
          }

          if (this.handLandmarks) {
            this.drawHandSkeleton();
          }
        }

        drawHandSkeleton() {
          const ctx = this.canvasCtx;
          const width = this.canvasElement.width;
          const height = this.canvasElement.height;

          const fingerTip = this.handLandmarks[this.fingerTipIndex];

          const isFrontCamera = this.currentFacingMode.includes("user");
          const isRightHand = this.handType === "Right";

          let shouldFlipX;
          if (isFrontCamera) {
            shouldFlipX = !isRightHand;
          } else {
            shouldFlipX = true;
          }

          const fingerX = shouldFlipX
            ? width - fingerTip.x * width
            : fingerTip.x * width;
          const fingerY = fingerTip.y * height;

          ctx.strokeStyle = "#4ECDC4";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(fingerX, fingerY, 15, 0, 2 * Math.PI);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(fingerX - 10, fingerY);
          ctx.lineTo(fingerX + 10, fingerY);
          ctx.moveTo(fingerX, fingerY - 10);
          ctx.lineTo(fingerX, fingerY + 10);
          ctx.stroke();

          ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
          ctx.lineWidth = 2;
          const handConnections = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17],
          ];

          handConnections.forEach((connection) => {
            const start = this.handLandmarks[connection[0]];
            const end = this.handLandmarks[connection[1]];

            const startX = shouldFlipX
              ? width - start.x * width
              : start.x * width;
            const startY = start.y * height;
            const endX = shouldFlipX ? width - end.x * width : end.x * width;
            const endY = end.y * height;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          });

          // Auto-burst when crosshair overlaps a bubble
          if (this.gameStarted && this.bubbles && this.bubbles.length) {
            for (let i = this.bubbles.length - 1; i >= 0; i--) {
              const b = this.bubbles[i];
              const dx = fingerX - b.x;
              const dy = fingerY - b.y;
              if (dx * dx + dy * dy <= b.radius * b.radius) {
                this.popBubble(i, fingerX, fingerY);
                break;
              }
            }
          }
        }

        updateGameStats() {
          if (this.gameStarted) {
            this.gameTime = Math.floor(
              (Date.now() - this.gameStartTime) / 1000
            );
            const minutes = Math.floor(this.gameTime / 60);
            const seconds = this.gameTime % 60;
            document.getElementById(
              "game-time"
            ).textContent = `${minutes}:${seconds.toString().padStart(2, "0")}`;
          }

          document.getElementById("balloon-count").textContent =
            this.bubbles.length;
        }

        gameLoop() {
          if (!this.gameStarted) return;

          const now = performance.now();
          if (!this.lastFrameTime) this.lastFrameTime = now;

          const frameInterval = 33;
          const elapsed = now - this.lastFrameTime;

          if (elapsed > frameInterval) {
            this.lastFrameTime = now - (elapsed % frameInterval);

            this.updateBubbles();
            this.render();
            this.updateGameStats();
          }

          requestAnimationFrame(() => this.gameLoop());
        }

        resetGame() {
          this.score = 0;
          this.gameTime = 0;
          this.gameStartTime = Date.now();
          this.bubbles = [];
          this.particles = [];

          const handStatus = document.getElementById("hand-status-indicator");
          if (handStatus) {
            handStatus.textContent = "Active";
            handStatus.style.color = "#4ECDC4";
          }

          document.getElementById("score").textContent = "0";
          document.getElementById("game-time").textContent = "0:00";
          document.getElementById("balloon-count").textContent = "0";
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        new BubblePopGame();
      });
    </script>
  </body>
</html>